#!/usr/bin/env python3

import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, Gdk, GLib, Vte
import neovim
import uuid
import time
import sys
import threading

class NeovimWindow(Gtk.ApplicationWindow):

    def __init__(self, *args, **kwargs):
        Gtk.ApplicationWindow.__init__(self, *args, **kwargs)
        self.header = Gtk.HeaderBar(title=self.get_title(),
                                    show_close_button=True)
        self.set_titlebar(self.header)
        self.box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL,
                           parent=self)
        self.ntb = None
        self.vte = Vte.Terminal(scrollback_lines=0,
                                scroll_on_output=False,
                                scroll_on_keystroke=True,
                                rewrap_on_resize=True,
                                vexpand=True)
        self.vte.set_mouse_autohide(True)
        self.vte.grab_focus()
        self.box.pack_end(self.vte, True, True, 0)
        self.buffers = []
        self.tabs = []

    def start(self):
        path = '/tmp/nvim{}'.format(uuid.uuid4())
        self.vte.spawn_sync(Vte.PtyFlags.DEFAULT,
                            None,
                            ['/usr/bin/nvim'] + sys.argv[1:],
                            ['NVIM_LISTEN_ADDRESS={}'.format(path),
                             'NVIM_TUI_ENABLE_CURSOR_SHAPE=1',
                             'NVIM_TUI_ENABLE_TRUE_COLOR=1'],
                            GLib.SpawnFlags.DEFAULT,
                            None,
                            None,
                            None)
        time.sleep(0.01)
        self.vim = neovim.attach('socket', path=path)
        self.vte.connect('child-exited', lambda *args: self.vte.get_toplevel().close())
        self.show_all()
        threading.Thread(target=self._on_start_loop, daemon=True).start()
        Gtk.main()

    def _on_start_loop(self):
        self.vim.options['showtabline'] = 0
        self._update_background()
        self._subscribe_events('buffers',
                               'TextChanged',
                               'InsertLeave',
                               'BufEnter',
                               'BufLeave',
                               'BufWrite',
                               'TermClose')
        self._subscribe_events('tabs',
                               'TabEnter',
                               'TabLeave',
                               'TabNew',
                               'TabClosed')
        self.vim.run_loop(lambda: None, self._on_notification)

    def _update_background(self):
        bgr = Gdk.RGBA()
        bgr.parse(self.vim.eval('synIDattr(hlID("Normal"),"bg")'))
        self.vte.set_color_background(bgr)

    def _subscribe_events(self, label, *events):
        self.vim.subscribe(label)
        self.vim.command('au {} * call rpcnotify({}, "{}")'.format(','.join(events),
                                                                   self.vim.channel_id,
                                                                   label))

    def _on_notification(self, label, data):
        if label == 'buffers':
            buffers = self._get_buffer_info()
            if self.buffers != buffers:
                self.buffers = buffers
                GLib.idle_add(self._refresh_buffers)
            self._on_notification('tabs', None)
        if label == 'tabs':
            tabs = self._get_tab_info()
            if self.tabs != tabs:
                self.tabs = tabs
                GLib.idle_add(self._refresh_tab_list)

    def _get_buffer_info(self):
        return [(self._get_buffer_name(b.name),
                 self.vim.current.buffer == b,
                 self.vim.call('getbufvar', b.handle, '&mod'))
                for b in sorted(self.vim.buffers, key=lambda b: b.handle)
                if b.valid and b.name != '' and self.vim.call('buflisted', b.handle)]

    def _get_tab_info(self):
        return [(self._get_buffer_name(t.window.buffer.name),
                 self.vim.current.tabpage == t)
                for t in sorted(self.vim.tabpages, key=lambda t: t.handle)
                if t.valid]

    def _refresh_buffers(self):
        if len(self.buffers) is 0:
            self.header.set_custom_title(None)
            return
        ssw = Gtk.StackSwitcher()
        for name, current, modified in self.buffers:
            Gtk.ToggleButton(name,
                             active=current,
                             image=Gtk.Image(icon_name='edit') if modified else None,
                             always_show_image=modified,
                             parent=ssw)
        self.header.set_custom_title(ssw)
        self.header.show_all()

    def _refresh_tab_list(self):
        if self.ntb is not None:
            self.ntb.destroy()
        if len(self.tabs) < 2:
            return
        self.ntb = Gtk.Notebook(parent=self.box)
        for name, current in self.tabs:
            page = Gtk.Box()
            self.ntb.append_page(page, Gtk.Label(name if name != '' else '[No Name]'))
            page.show_all()
            if current:
                self.ntb.set_current_page(self.ntb.get_n_pages() - 1)
        self.ntb.show_all()

    def _get_buffer_name(self, name):
        return self.vim.call('pathshorten', self.vim.call('fnamemodify', name, ':~:.'))


if __name__ == '__main__':
    app = Gtk.Application(application_id='org.nvim-pygtk3')
    app.connect('activate', lambda *args: NeovimWindow(application=app,
                                                       title='Neovim',
                                                       icon_name='vim').start())
    app.run(sys.argv)
